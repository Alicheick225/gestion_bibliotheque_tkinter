import tkinter as tk
from tkinter import ttk, messagebox
import customtkinter as ctk
from datetime import datetime, timedelta

class LibraryApp:
    def __init__(self, root):
        self.root = root
        self.root.title("BookWorm Haven - Library Management")
        self.root.geometry("1200x800")
        
        # Configure customtkinter appearance
        ctk.set_appearance_mode("dark")  # Default to dark mode
        ctk.set_default_color_theme("blue")  # Default blue theme
        
        # Initialize database (in-memory for this example)
        self.books = []
        self.members = []
        self.transactions = []
        
        # Create main container
        self.main_frame = ctk.CTkFrame(root)
        self.main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Create notebook for tabs
        self.notebook = ttk.Notebook(self.main_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # Create tabs
        self.create_dashboard_tab()
        self.create_books_tab()
        self.create_members_tab()
        self.create_transactions_tab()
        self.create_settings_tab()
        
        # Initialize with dashboard
        self.notebook.select(0)
    
    def create_dashboard_tab(self):
        """Create dashboard tab with summary statistics"""
        tab = ctk.CTkFrame(self.notebook)
        self.notebook.add(tab, text="Dashboard")
        
        # Dashboard widgets
        title_label = ctk.CTkLabel(tab, text="Library Dashboard", font=("Arial", 24, "bold"))
        title_label.pack(pady=20)
        
        # Stats frame
        stats_frame = ctk.CTkFrame(tab)
        stats_frame.pack(fill=tk.X, padx=20, pady=10)
        
        # Stats cards
        stats = [
            ("Total Books", len(self.books)),
            ("Total Members", len(self.members)),
            ("Books Checked Out", len([t for t in self.transactions if t["return_date"] is None])),
            ("Overdue Books", len([t for t in self.transactions 
                                 if t["return_date"] is None and 
                                 datetime.strptime(t["due_date"], "%Y-%m-%d") < datetime.now()]))
        ]
        
        for i, (label, value) in enumerate(stats):
            card = ctk.CTkFrame(stats_frame, height=120)
            card.grid(row=0, column=i, padx=10, pady=10, sticky="nsew")
            stats_frame.columnconfigure(i, weight=1)
            
            lbl = ctk.CTkLabel(card, text=label, font=("Arial", 14))
            lbl.pack(pady=(10, 5))
            
            val = ctk.CTkLabel(card, text=str(value), font=("Arial", 24, "bold"))
            val.pack(pady=(0, 10))
        
        # Recent activity frame
        activity_frame = ctk.CTkFrame(tab)
        activity_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        activity_label = ctk.CTkLabel(activity_frame, text="Recent Activity", font=("Arial", 16))
        activity_label.pack(pady=10)
        
        columns = ("ID", "Book", "Member", "Date", "Status")
        self.activity_tree = ttk.Treeview(activity_frame, columns=columns, show="headings", height=10)
        
        for col in columns:
            self.activity_tree.heading(col, text=col)
            self.activity_tree.column(col, width=120, anchor=tk.CENTER)
        
        self.activity_tree.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Add sample data (in a real app, this would come from database)
        self.refresh_dashboard()
    
    def create_books_tab(self):
        """Create books management tab"""
        tab = ctk.CTkFrame(self.notebook)
        self.notebook.add(tab, text="Books")
        
        # Search and add frame
        search_frame = ctk.CTkFrame(tab)
        search_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.book_search = ctk.CTkEntry(search_frame, placeholder_text="Search books...")
        self.book_search.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        
        search_btn = ctk.CTkButton(search_frame, text="Search", width=100, command=self.search_books)
        search_btn.pack(side=tk.LEFT)
        
        add_btn = ctk.CTkButton(search_frame, text="Add Book", width=100, command=self.show_add_book_dialog)
        add_btn.pack(side=tk.RIGHT)
        
        # Books table
        columns = ("ID", "Title", "Author", "ISBN", "Genre", "Available")
        self.books_tree = ttk.Treeview(tab, columns=columns, show="headings", height=20)
        
        for col in columns:
            self.books_tree.heading(col, text=col)
            self.books_tree.column(col, width=120, anchor=tk.CENTER)
        
        self.books_tree.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))
        
        # Action buttons
        btn_frame = ctk.CTkFrame(tab)
        btn_frame.pack(fill=tk.X, padx=10, pady=10)
        
        edit_btn = ctk.CTkButton(btn_frame, text="Edit", command=self.edit_book)
        edit_btn.pack(side=tk.LEFT, padx=5)
        
        delete_btn = ctk.CTkButton(btn_frame, text="Delete", command=self.delete_book)
        delete_btn.pack(side=tk.LEFT, padx=5)
        
        checkout_btn = ctk.CTkButton(btn_frame, text="Check Out", command=self.checkout_book_dialog)
        checkout_btn.pack(side=tk.RIGHT, padx=5)
        
        # Add sample books
        self.refresh_books()
    
    def create_members_tab(self):
        """Create members management tab"""
        tab = ctk.CTkFrame(self.notebook)
        self.notebook.add(tab, text="Members")
        
        # Search and add frame
        search_frame = ctk.CTkFrame(tab)
        search_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.member_search = ctk.CTkEntry(search_frame, placeholder_text="Search members...")
        self.member_search.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        
        search_btn = ctk.CTkButton(search_frame, text="Search", width=100, command=self.search_members)
        search_btn.pack(side=tk.LEFT)
        
        add_btn = ctk.CTkButton(search_frame, text="Add Member", width=100, command=self.show_add_member_dialog)
        add_btn.pack(side=tk.RIGHT)
        
        # Members table
        columns = ("ID", "Name", "Email", "Phone", "Membership Date", "Books Checked Out")
        self.members_tree = ttk.Treeview(tab, columns=columns, show="headings", height=20)
        
        for col in columns:
            self.members_tree.heading(col, text=col)
            self.members_tree.column(col, width=120, anchor=tk.CENTER)
        
        self.members_tree.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))
        
        # Action buttons
        btn_frame = ctk.CTkFrame(tab)
        btn_frame.pack(fill=tk.X, padx=10, pady=10)
        
        edit_btn = ctk.CTkButton(btn_frame, text="Edit", command=self.edit_member)
        edit_btn.pack(side=tk.LEFT, padx=5)
        
        delete_btn = ctk.CTkButton(btn_frame, text="Delete", command=self.delete_member)
        delete_btn.pack(side=tk.LEFT, padx=5)
        
        # Add sample members
        self.refresh_members()
    
    def create_transactions_tab(self):
        """Create transactions management tab"""
        tab = ctk.CTkFrame(self.notebook)
        self.notebook.add(tab, text="Transactions")
        
        # Search frame
        search_frame = ctk.CTkFrame(tab)
        search_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.transaction_search = ctk.CTkEntry(search_frame, placeholder_text="Search transactions...")
        self.transaction_search.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        
        search_btn = ctk.CTkButton(search_frame, text="Search", width=100, command=self.search_transactions)
        search_btn.pack(side=tk.LEFT)
        
        # Transactions table
        columns = ("ID", "Book", "Member", "Checkout Date", "Due Date", "Return Date", "Status")
        self.transactions_tree = ttk.Treeview(tab, columns=columns, show="headings", height=20)
        
        for col in columns:
            self.transactions_tree.heading(col, text=col)
            self.transactions_tree.column(col, width=120, anchor=tk.CENTER)
        
        self.transactions_tree.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))
        
        # Action buttons
        btn_frame = ctk.CTkFrame(tab)
        btn_frame.pack(fill=tk.X, padx=10, pady=10)
        
        return_btn = ctk.CTkButton(btn_frame, text="Return Book", command=self.return_book)
        return_btn.pack(side=tk.LEFT, padx=5)
        
        renew_btn = ctk.CTkButton(btn_frame, text="Renew Loan", command=self.renew_loan)
        renew_btn.pack(side=tk.LEFT, padx=5)
        
        # Add sample transactions
        self.refresh_transactions()
    
    def create_settings_tab(self):
        """Create settings tab"""
        tab = ctk.CTkFrame(self.notebook)
        self.notebook.add(tab, text="Settings")
        
        # Appearance settings
        appearance_frame = ctk.CTkFrame(tab)
        appearance_frame.pack(fill=tk.X, padx=20, pady=20)
        
        appearance_label = ctk.CTkLabel(appearance_frame, text="Appearance Settings", font=("Arial", 16))
        appearance_label.pack(pady=10)
        
        # Theme mode
        mode_label = ctk.CTkLabel(appearance_frame, text="Theme Mode:")
        mode_label.pack(anchor=tk.W, padx=10)
        
        self.mode_var = tk.StringVar(value="dark")
        mode_options = ["light", "dark", "system"]
        
        for mode in mode_options:
            rb = ctk.CTkRadioButton(appearance_frame, text=mode.capitalize(), 
                                   variable=self.mode_var, value=mode,
                                   command=self.change_theme_mode)
            rb.pack(anchor=tk.W, padx=20)
        
        # Color theme
        color_label = ctk.CTkLabel(appearance_frame, text="Color Theme:")
        color_label.pack(anchor=tk.W, padx=10, pady=(10, 0))
        
        self.color_var = tk.StringVar(value="blue")
        color_options = ["blue", "green", "dark-blue"]
        
        color_frame = ctk.CTkFrame(appearance_frame)
        color_frame.pack(fill=tk.X, padx=10, pady=5)
        
        for color in color_options:
            rb = ctk.CTkRadioButton(color_frame, text=color.capitalize(), 
                                   variable=self.color_var, value=color,
                                   command=self.change_color_theme)
            rb.pack(side=tk.LEFT, padx=10)
        
        # System settings
        system_frame = ctk.CTkFrame(tab)
        system_frame.pack(fill=tk.X, padx=20, pady=20)
        
        system_label = ctk.CTkLabel(system_frame, text="System Settings", font=("Arial", 16))
        system_label.pack(pady=10)
        
        # Loan duration
        loan_label = ctk.CTkLabel(system_frame, text="Default Loan Duration (days):")
        loan_label.pack(anchor=tk.W, padx=10)
        
        self.loan_duration = ctk.CTkEntry(system_frame, placeholder_text="14")
        self.loan_duration.pack(anchor=tk.W, padx=20, pady=5)
        
        # Save settings button
        save_btn = ctk.CTkButton(system_frame, text="Save Settings", command=self.save_settings)
        save_btn.pack(pady=20)
    
    # ========== DATA MANAGEMENT METHODS ==========
    
    def refresh_dashboard(self):
        """Refresh dashboard data"""
        # Clear existing data
        for item in self.activity_tree.get_children():
            self.activity_tree.delete(item)
        
        # Add sample transactions (sorted by date, newest first)
        sample_transactions = sorted([
            {
                "id": 1,
                "book": "The Great Gatsby",
                "member": "John Doe",
                "date": "2023-05-15",
                "status": "Returned"
            },
            {
                "id": 2,
                "book": "To Kill a Mockingbird",
                "member": "Jane Smith",
                "date": "2023-05-18",
                "status": "Checked Out"
            },
            {
                "id": 3,
                "book": "1984",
                "member": "Bob Johnson",
                "date": "2023-05-20",
                "status": "Overdue"
            }
        ], key=lambda x: x["date"], reverse=True)
        
        for t in sample_transactions:
            self.activity_tree.insert("", tk.END, values=(
                t["id"], t["book"], t["member"], t["date"], t["status"]
            ))
    
    def refresh_books(self):
        """Refresh books list"""
        # Clear existing data
        for item in self.books_tree.get_children():
            self.books_tree.delete(item)
        
        # Add sample books
        self.books = [
            {
                "id": 1,
                "title": "The Great Gatsby",
                "author": "F. Scott Fitzgerald",
                "isbn": "9780743273565",
                "genre": "Classic",
                "available": True
            },
            {
                "id": 2,
                "title": "To Kill a Mockingbird",
                "author": "Harper Lee",
                "isbn": "9780061120084",
                "genre": "Fiction",
                "available": True
            },
            {
                "id": 3,
                "title": "1984",
                "author": "George Orwell",
                "isbn": "9780451524935",
                "genre": "Dystopian",
                "available": False
            },
            {
                "id": 4,
                "title": "Pride and Prejudice",
                "author": "Jane Austen",
                "isbn": "9781503290563",
                "genre": "Romance",
                "available": True
            }
        ]
        
        for book in self.books:
            self.books_tree.insert("", tk.END, values=(
                book["id"],
                book["title"],
                book["author"],
                book["isbn"],
                book["genre"],
                "Yes" if book["available"] else "No"
            ))
    
    def refresh_members(self):
        """Refresh members list"""
        # Clear existing data
        for item in self.members_tree.get_children():
            self.members_tree.delete(item)
        
        # Add sample members
        self.members = [
            {
                "id": 1,
                "name": "John Doe",
                "email": "john@example.com",
                "phone": "555-0101",
                "membership_date": "2022-01-15",
                "books_checked_out": 1
            },
            {
                "id": 2,
                "name": "Jane Smith",
                "email": "jane@example.com",
                "phone": "555-0102",
                "membership_date": "2022-03-20",
                "books_checked_out": 0
            },
            {
                "id": 3,
                "name": "Bob Johnson",
                "email": "bob@example.com",
                "phone": "555-0103",
                "membership_date": "2023-01-05",
                "books_checked_out": 1
            }
        ]
        
        for member in self.members:
            self.members_tree.insert("", tk.END, values=(
                member["id"],
                member["name"],
                member["email"],
                member["phone"],
                member["membership_date"],
                member["books_checked_out"]
            ))
    
    def refresh_transactions(self):
        """Refresh transactions list"""
        # Clear existing data
        for item in self.transactions_tree.get_children():
            self.transactions_tree.delete(item)
        
        # Add sample transactions
        self.transactions = [
            {
                "id": 1,
                "book_id": 1,
                "book_title": "The Great Gatsby",
                "member_id": 1,
                "member_name": "John Doe",
                "checkout_date": "2023-05-01",
                "due_date": "2023-05-15",
                "return_date": "2023-05-15"
            },
            {
                "id": 2,
                "book_id": 3,
                "book_title": "1984",
                "member_id": 3,
                "member_name": "Bob Johnson",
                "checkout_date": "2023-05-10",
                "due_date": "2023-05-24",
                "return_date": None
            },
            {
                "id": 3,
                "book_id": 2,
                "book_title": "To Kill a Mockingbird",
                "member_id": 2,
                "member_name": "Jane Smith",
                "checkout_date": "2023-05-18",
                "due_date": "2023-06-01",
                "return_date": None
            }
        ]
        
        for t in self.transactions:
            status = "Returned" if t["return_date"] else "Checked Out"
            if not t["return_date"] and datetime.strptime(t["due_date"], "%Y-%m-%d") < datetime.now():
                status = "Overdue"
            
            self.transactions_tree.insert("", tk.END, values=(
                t["id"],
                t["book_title"],
                t["member_name"],
                t["checkout_date"],
                t["due_date"],
                t["return_date"] if t["return_date"] else "-",
                status
            ))
    
    # ========== DIALOG METHODS ==========
    
    def show_add_book_dialog(self):
        """Show dialog to add a new book"""
        dialog = ctk.CTkToplevel(self.root)
        dialog.title("Add New Book")
        dialog.geometry("500x400")
        dialog.resizable(False, False)
        dialog.grab_set()  # Make dialog modal
        
        # Form fields
        fields = [
            ("Title", "entry"),
            ("Author", "entry"),
            ("ISBN", "entry"),
            ("Genre", "combobox", ["Fiction", "Non-Fiction", "Classic", "Romance", "Dystopian", "Mystery", "Biography"]),
            ("Available", "checkbutton", "Yes")
        ]
        
        entries = {}
        
        for i, (label, field_type, *options) in enumerate(fields):
            lbl = ctk.CTkLabel(dialog, text=label + ":")
            lbl.grid(row=i, column=0, padx=10, pady=5, sticky="e")
            
            if field_type == "entry":
                entry = ctk.CTkEntry(dialog, width=300)
                entry.grid(row=i, column=1, padx=10, pady=5, sticky="w")
                entries[label.lower()] = entry
            elif field_type == "combobox":
                combo = ctk.CTkComboBox(dialog, width=300, values=options[0])
                combo.grid(row=i, column=1, padx=10, pady=5, sticky="w")
                entries[label.lower()] = combo
            elif field_type == "checkbutton":
                var = tk.BooleanVar(value=True)
                cb = ctk.CTkCheckBox(dialog, text="", variable=var)
                cb.grid(row=i, column=1, padx=10, pady=5, sticky="w")
                entries[label.lower()] = var
        
        # Buttons
        btn_frame = ctk.CTkFrame(dialog)
        btn_frame.grid(row=len(fields)+1, column=0, columnspan=2, pady=20)
        
        save_btn = ctk.CTkButton(btn_frame, text="Save", width=100, 
                                command=lambda: self.save_book(dialog, entries))
        save_btn.pack(side=tk.LEFT, padx=10)
        
        cancel_btn = ctk.CTkButton(btn_frame, text="Cancel", width=100, 
                                  command=dialog.destroy)
        cancel_btn.pack(side=tk.RIGHT, padx=10)
    
    def show_add_member_dialog(self):
        """Show dialog to add a new member"""
        dialog = ctk.CTkToplevel(self.root)
        dialog.title("Add New Member")
        dialog.geometry("500x350")
        dialog.resizable(False, False)
        dialog.grab_set()  # Make dialog modal
        
        # Form fields
        fields = [
            ("Name", "entry"),
            ("Email", "entry"),
            ("Phone", "entry"),
            ("Membership Date", "entry", datetime.now().strftime("%Y-%m-%d"))
        ]
        
        entries = {}
        
        for i, (label, field_type, *default_value) in enumerate(fields):
            lbl = ctk.CTkLabel(dialog, text=label + ":")
            lbl.grid(row=i, column=0, padx=10, pady=5, sticky="e")
            
            if field_type == "entry":
                entry = ctk.CTkEntry(dialog, width=300)
                if default_value:
                    entry.insert(0, default_value[0])
                entry.grid(row=i, column=1, padx=10, pady=5, sticky="w")
                entries[label.lower().replace(" ", "_")] = entry
        
        # Buttons
        btn_frame = ctk.CTkFrame(dialog)
        btn_frame.grid(row=len(fields)+1, column=0, columnspan=2, pady=20)
        
        save_btn = ctk.CTkButton(btn_frame, text="Save", width=100, 
                                command=lambda: self.save_member(dialog, entries))
        save_btn.pack(side=tk.LEFT, padx=10)
        
        cancel_btn = ctk.CTkButton(btn_frame, text="Cancel", width=100, 
                                  command=dialog.destroy)
        cancel_btn.pack(side=tk.RIGHT, padx=10)
    
    def checkout_book_dialog(self):
        """Show dialog to checkout a book"""
        selected = self.books_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a book to check out")
            return
        
        book_id = self.books_tree.item(selected[0])["values"][0]
        book = next((b for b in self.books if b["id"] == book_id), None)
        
        if not book["available"]:
            messagebox.showwarning("Warning", "This book is already checked out")
            return
        
        dialog = ctk.CTkToplevel(self.root)
        dialog.title("Check Out Book")
        dialog.geometry("500x300")
        dialog.resizable(False, False)
        dialog.grab_set()  # Make dialog modal
        
        # Book info
        book_frame = ctk.CTkFrame(dialog)
        book_frame.pack(fill=tk.X, padx=10, pady=10)
        
        ctk.CTkLabel(book_frame, text="Book:").pack(anchor=tk.W)
        ctk.CTkLabel(book_frame, text=book["title"], font=("Arial", 14, "bold")).pack(anchor=tk.W)
        
        # Member selection
        member_frame = ctk.CTkFrame(dialog)
        member_frame.pack(fill=tk.X, padx=10, pady=10)
        
        ctk.CTkLabel(member_frame, text="Member:").pack(anchor=tk.W)
        
        member_names = [f"{m['id']} - {m['name']}" for m in self.members]
        member_combo = ctk.CTkComboBox(member_frame, values=member_names)
        member_combo.pack(fill=tk.X, pady=5)
        
        # Due date
        date_frame = ctk.CTkFrame(dialog)
        date_frame.pack(fill=tk.X, padx=10, pady=10)
        
        due_date = (datetime.now() + timedelta(days=14)).strftime("%Y-%m-%d")
        ctk.CTkLabel(date_frame, text=f"Due Date: {due_date}").pack(anchor=tk.W)
        
        # Buttons
        btn_frame = ctk.CTkFrame(dialog)
        btn_frame.pack(fill=tk.X, padx=10, pady=10)
        
        checkout_btn = ctk.CTkButton(btn_frame, text="Check Out", 
                                    command=lambda: self.process_checkout(
                                        dialog, book_id, member_combo.get(), due_date))
        checkout_btn.pack(side=tk.LEFT, padx=10)
        
        cancel_btn = ctk.CTkButton(btn_frame, text="Cancel", command=dialog.destroy)
        cancel_btn.pack(side=tk.RIGHT, padx=10)
    
    # ========== ACTION METHODS ==========
    
    def save_book(self, dialog, entries):
        """Save new book to database"""
        try:
            new_book = {
                "id": max(b["id"] for b in self.books) + 1 if self.books else 1,
                "title": entries["title"].get(),
                "author": entries["author"].get(),
                "isbn": entries["isbn"].get(),
                "genre": entries["genre"].get(),
                "available": entries["available"].get()
            }
            
            self.books.append(new_book)
            self.refresh_books()
            dialog.destroy()
            messagebox.showinfo("Success", "Book added successfully!")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to add book: {str(e)}")
    
    def save_member(self, dialog, entries):
        """Save new member to database"""
        try:
            new_member = {
                "id": max(m["id"] for m in self.members) + 1 if self.members else 1,
                "name": entries["name"].get(),
                "email": entries["email"].get(),
                "phone": entries["phone"].get(),
                "membership_date": entries["membership_date"].get(),
                "books_checked_out": 0
            }
            
            self.members.append(new_member)
            self.refresh_members()
            dialog.destroy()
            messagebox.showinfo("Success", "Member added successfully!")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to add member: {str(e)}")
    
    def process_checkout(self, dialog, book_id, member_str, due_date):
        """Process book checkout"""
        try:
            member_id = int(member_str.split(" - ")[0])
            
            new_transaction = {
                "id": max(t["id"] for t in self.transactions) + 1 if self.transactions else 1,
                "book_id": book_id,
                "book_title": next(b["title"] for b in self.books if b["id"] == book_id),
                "member_id": member_id,
                "member_name": next(m["name"] for m in self.members if m["id"] == member_id),
                "checkout_date": datetime.now().strftime("%Y-%m-%d"),
                "due_date": due_date,
                "return_date": None
            }
            
            # Update book availability
            for book in self.books:
                if book["id"] == book_id:
                    book["available"] = False
                    break
            
            # Update member's books checked out count
            for member in self.members:
                if member["id"] == member_id:
                    member["books_checked_out"] += 1
                    break
            
            self.transactions.append(new_transaction)
            self.refresh_books()
            self.refresh_members()
            self.refresh_transactions()
            dialog.destroy()
            messagebox.showinfo("Success", "Book checked out successfully!")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to check out book: {str(e)}")
    
    def return_book(self):
        """Return a checked out book"""
        selected = self.transactions_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a transaction")
            return
        
        transaction_id = self.transactions_tree.item(selected[0])["values"][0]
        transaction = next((t for t in self.transactions if t["id"] == transaction_id), None)
        
        if transaction["return_date"] is not None:
            messagebox.showwarning("Warning", "This book has already been returned")
            return
        
        # Update transaction
        transaction["return_date"] = datetime.now().strftime("%Y-%m-%d")
        
        # Update book availability
        for book in self.books:
            if book["id"] == transaction["book_id"]:
                book["available"] = True
                break
        
        # Update member's books checked out count
        for member in self.members:
            if member["id"] == transaction["member_id"]:
                member["books_checked_out"] -= 1
                break
        
        self.refresh_books()
        self.refresh_members()
        self.refresh_transactions()
        messagebox.showinfo("Success", "Book returned successfully!")
    
    def renew_loan(self):
        """Renew a book loan"""
        selected = self.transactions_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a transaction")
            return
        
        transaction_id = self.transactions_tree.item(selected[0])["values"][0]
        transaction = next((t for t in self.transactions if t["id"] == transaction_id), None)
        
        if transaction["return_date"] is not None:
            messagebox.showwarning("Warning", "This book has already been returned")
            return
        
        # Renew for another 14 days
        new_due_date = (datetime.strptime(transaction["due_date"], "%Y-%m-%d") + 
                       timedelta(days=14)).strftime("%Y-%m-%d")
        transaction["due_date"] = new_due_date
        
        self.refresh_transactions()
        messagebox.showinfo("Success", f"Loan renewed until {new_due_date}")
    
    def edit_book(self):
        """Edit selected book"""
        selected = self.books_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a book to edit")
            return
        
        book_id = self.books_tree.item(selected[0])["values"][0]
        book = next((b for b in self.books if b["id"] == book_id), None)
        
        dialog = ctk.CTkToplevel(self.root)
        dialog.title("Edit Book")
        dialog.geometry("500x400")
        dialog.resizable(False, False)
        dialog.grab_set()  # Make dialog modal
        
        # Form fields
        fields = [
            ("Title", "entry", book["title"]),
            ("Author", "entry", book["author"]),
            ("ISBN", "entry", book["isbn"]),
            ("Genre", "combobox", ["Fiction", "Non-Fiction", "Classic", "Romance", "Dystopian", "Mystery", "Biography"], book["genre"]),
            ("Available", "checkbutton", "Yes" if book["available"] else "No")
        ]
        
        entries = {}
        
        for i, (label, field_type, *options) in enumerate(fields):
            lbl = ctk.CTkLabel(dialog, text=label + ":")
            lbl.grid(row=i, column=0, padx=10, pady=5, sticky="e")
            
            if field_type == "entry":
                entry = ctk.CTkEntry(dialog, width=300)
                entry.insert(0, options[0])
                entry.grid(row=i, column=1, padx=10, pady=5, sticky="w")
                entries[label.lower()] = entry
            elif field_type == "combobox":
                combo = ctk.CTkComboBox(dialog, width=300, values=options[0])
                combo.set(options[1])
                combo.grid(row=i, column=1, padx=10, pady=5, sticky="w")
                entries[label.lower()] = combo
            elif field_type == "checkbutton":
                var = tk.BooleanVar(value=options[0] == "Yes")
                cb = ctk.CTkCheckBox(dialog, text="", variable=var)
                cb.grid(row=i, column=1, padx=10, pady=5, sticky="w")
                entries[label.lower()] = var
        
        # Buttons
        btn_frame = ctk.CTkFrame(dialog)
        btn_frame.grid(row=len(fields)+1, column=0, columnspan=2, pady=20)
        
        save_btn = ctk.CTkButton(btn_frame, text="Save", width=100, 
                                command=lambda: self.update_book(dialog, book_id, entries))
        save_btn.pack(side=tk.LEFT, padx=10)
        
        cancel_btn = ctk.CTkButton(btn_frame, text="Cancel", width=100, 
                                  command=dialog.destroy)
        cancel_btn.pack(side=tk.RIGHT, padx=10)
    
    def update_book(self, dialog, book_id, entries):
        """Update book information"""
        try:
            for book in self.books:
                if book["id"] == book_id:
                    book["title"] = entries["title"].get()
                    book["author"] = entries["author"].get()
                    book["isbn"] = entries["isbn"].get()
                    book["genre"] = entries["genre"].get()
                    book["available"] = entries["available"].get()
                    break
            
            self.refresh_books()
            dialog.destroy()
            messagebox.showinfo("Success", "Book updated successfully!")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to update book: {str(e)}")
    
    def delete_book(self):
        """Delete selected book"""
        selected = self.books_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a book to delete")
            return
        
        book_id = self.books_tree.item(selected[0])["values"][0]
        
        # Check if book is checked out
        if any(t["book_id"] == book_id and t["return_date"] is None for t in self.transactions):
            messagebox.showwarning("Warning", "Cannot delete a book that is checked out")
            return
        
        if messagebox.askyesno("Confirm", "Are you sure you want to delete this book?"):
            self.books = [b for b in self.books if b["id"] != book_id]
            self.refresh_books()
            messagebox.showinfo("Success", "Book deleted successfully!")
    
    def edit_member(self):
        """Edit selected member"""
        selected = self.members_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a member to edit")
            return
        
        member_id = self.members_tree.item(selected[0])["values"][0]
        member = next((m for m in self.members if m["id"] == member_id), None)
        
        dialog = ctk.CTkToplevel(self.root)
        dialog.title("Edit Member")
        dialog.geometry("500x350")
        dialog.resizable(False, False)
        dialog.grab_set()  # Make dialog modal
        
        # Form fields
        fields = [
            ("Name", "entry", member["name"]),
            ("Email", "entry", member["email"]),
            ("Phone", "entry", member["phone"]),
            ("Membership Date", "entry", member["membership_date"])
        ]
        
        entries = {}
        
        for i, (label, field_type, default_value) in enumerate(fields):
            lbl = ctk.CTkLabel(dialog, text=label + ":")
            lbl.grid(row=i, column=0, padx=10, pady=5, sticky="e")
            
            if field_type == "entry":
                entry = ctk.CTkEntry(dialog, width=300)
                entry.insert(0, default_value)
                entry.grid(row=i, column=1, padx=10, pady=5, sticky="w")
                entries[label.lower().replace(" ", "_")] = entry
        
        # Buttons
        btn_frame = ctk.CTkFrame(dialog)
        btn_frame.grid(row=len(fields)+1, column=0, columnspan=2, pady=20)
        
        save_btn = ctk.CTkButton(btn_frame, text="Save", width=100, 
                                command=lambda: self.update_member(dialog, member_id, entries))
        save_btn.pack(side=tk.LEFT, padx=10)
        
        cancel_btn = ctk.CTkButton(btn_frame, text="Cancel", width=100, 
                                  command=dialog.destroy)
        cancel_btn.pack(side=tk.RIGHT, padx=10)
    
    def update_member(self, dialog, member_id, entries):
        """Update member information"""
        try:
            for member in self.members:
                if member["id"] == member_id:
                    member["name"] = entries["name"].get()
                    member["email"] = entries["email"].get()
                    member["phone"] = entries["phone"].get()
                    member["membership_date"] = entries["membership_date"].get()
                    break
            
            self.refresh_members()
            dialog.destroy()
            messagebox.showinfo("Success", "Member updated successfully!")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to update member: {str(e)}")
    
    def delete_member(self):
        """Delete selected member"""
        selected = self.members_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a member to delete")
            return
        
        member_id = self.members_tree.item(selected[0])["values"][0]
        
        # Check if member has books checked out
        if any(t["member_id"] == member_id and t["return_date"] is None for t in self.transactions):
            messagebox.showwarning("Warning", "Cannot delete a member with checked out books")
            return
        
        if messagebox.askyesno("Confirm", "Are you sure you want to delete this member?"):
            self.members = [m for m in self.members if m["id"] != member_id]
            self.refresh_members()
            messagebox.showinfo("Success", "Member deleted successfully!")
    
    # ========== SEARCH METHODS ==========
    
    def search_books(self):
        """Search books by title or author"""
        query = self.book_search.get().lower()
        
        if not query:
            self.refresh_books()
            return
        
        results = []
        for book in self.books:
            if (query in book["title"].lower() or 
                query in book["author"].lower() or 
                query in book["genre"].lower()):
                results.append(book)
        
        # Clear existing data
        for item in self.books_tree.get_children():
            self.books_tree.delete(item)
        
        # Add search results
        for book in results:
            self.books_tree.insert("", tk.END, values=(
                book["id"],
                book["title"],
                book["author"],
                book["isbn"],
                book["genre"],
                "Yes" if book["available"] else "No"
            ))
    
    def search_members(self):
        """Search members by name or email"""
        query = self.member_search.get().lower()
        
        if not query:
            self.refresh_members()
            return
        
        results = []
        for member in self.members:
            if (query in member["name"].lower() or 
                query in member["email"].lower()):
                results.append(member)
        
        # Clear existing data
        for item in self.members_tree.get_children():
            self.members_tree.delete(item)
        
        # Add search results
        for member in results:
            self.members_tree.insert("", tk.END, values=(
                member["id"],
                member["name"],
                member["email"],
                member["phone"],
                member["membership_date"],
                member["books_checked_out"]
            ))
    
    def search_transactions(self):
        """Search transactions by book or member"""
        query = self.transaction_search.get().lower()
        
        if not query:
            self.refresh_transactions()
            return
        
        results = []
        for t in self.transactions:
            if (query in t["book_title"].lower() or 
                query in t["member_name"].lower()):
                results.append(t)
        
        # Clear existing data
        for item in self.transactions_tree.get_children():
            self.transactions_tree.delete(item)
        
        # Add search results
        for t in results:
            status = "Returned" if t["return_date"] else "Checked Out"
            if not t["return_date"] and datetime.strptime(t["due_date"], "%Y-%m-%d") < datetime.now():
                status = "Overdue"
            
            self.transactions_tree.insert("", tk.END, values=(
                t["id"],
                t["book_title"],
                t["member_name"],
                t["checkout_date"],
                t["due_date"],
                t["return_date"] if t["return_date"] else "-",
                status
            ))
    
    # ========== SETTINGS METHODS ==========
    
    def change_theme_mode(self):
        """Change theme mode (light/dark)"""
        ctk.set_appearance_mode(self.mode_var.get())
    
    def change_color_theme(self):
        """Change color theme"""
        ctk.set_default_color_theme(self.color_var.get())
    
    def save_settings(self):
        """Save system settings"""
        try:
            # In a real app, you would save these to a config file or database
            loan_duration = self.loan_duration.get()
            if loan_duration and not loan_duration.isdigit():
                raise ValueError("Loan duration must be a number")
            
            messagebox.showinfo("Success", "Settings saved successfully!")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save settings: {str(e)}")

if __name__ == "__main__":
    root = ctk.CTk()
    app = LibraryApp(root)
    root.mainloop()